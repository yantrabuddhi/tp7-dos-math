UNIT EVAL;
(* This program acts like a calculator - You type an expression	*)
(* and the program calculates its value. 	*)
(* There are five different operators (^,	*)
(* *, /, +, and -), and seven standard functions (ABS, SQRT,	*)
(* SIN, COS, ARCTAN, LN, and EXP). Parentheses within expres-	*)
(* sions are allowed. A special variable, called X, always	*)
(* holds the value FOR computation. 	*)

INTERFACE
TYPE
  EXPSTR = STRING;{BUT LENGTH OF INPUTTED STRING SHALL NOT EXCEED 80}
    {X-is the value replacement for appearing X variable}
PROCEDURE EVALUATE(EXPR: EXPSTR; X:REAL; VAR VALUE: REAL; VAR EXPERR,ERR:BOOLEAN);
FUNCTION PWRTEN(ET:INTEGER):REAL;
IMPLEMENTATION

FUNCTION VALC(NUM:REAL;VAR PWR:INTEGER):REAL;
VAR
    STNG:STRING;
    CNT:BYTE;
    P,EL:INTEGER;
    DECPOINT:BOOLEAN;
BEGIN
  STR(NUM:10:8,STNG);
  STNG[0]:=#10;
   EL:=0; P:=0; DECPOINT:=FALSE;
    FOR CNT:= 1 TO 10 DO
    BEGIN
     {NUM OF DIGITS CHECK} {IF CH<>'.' THEN P:=P+1}
      IF DECPOINT THEN EL:=EL-1;
      IF (STNG[CNT]='.') AND NOT DECPOINT THEN
      DECPOINT:=TRUE;
     END;{FOR}
            P:=10;
            VALC:=NUM;
            PWR:=P+EL;
 END;

FUNCTION PWRTEN(ET:INTEGER):REAL;
VAR PS,Y:INTEGER;XX:REAL;
BEGIN
PS:=ABS(ET);XX:=1;
IF ET<0 THEN FOR Y:=1 TO PS DO XX:=XX/10;
IF ET>0 THEN FOR Y:=1 TO PS DO XX:=XX*10;
PWRTEN:=XX;
END;

PROCEDURE EVALUATE(EXPR: EXPSTR; X:REAL; VAR VALUE: REAL; VAR EXPERR,ERR:BOOLEAN);
CONST              {NOW EXPR CAN BE MODIFIED}
  ERRCH = '?';
  EOFLINE = #13;
VAR
  POS: INTEGER;
  CH: CHAR;

PROCEDURE NEXTCHAR;
BEGIN
  REPEAT
    POS:=POS+1;
    IF POS<=LENGTH(EXPR) THEN
    CH:=EXPR[POS] ELSE
    CH:=EOFLINE;
  UNTIL CH<>' ';{ELIMINATING SPACES IF ANY}
END;

FUNCTION EXPRESSION: REAL;
VAR
  E,RR: REAL;
  OPR: CHAR;
  PR,NW:INTEGER;{PRE & NEW}

FUNCTION SIMEXPR: REAL;
VAR
  S,TT: REAL;
  QQ,CC:INTEGER;
  OPR: CHAR;

FUNCTION TERM: REAL;
VAR
  T,
  SGN,SFC: REAL;
  NN:INTEGER;

FUNCTION SIGNEDFACTOR(VAR SS:INTEGER): REAL;

FUNCTION FACTOR(VAR POW:INTEGER): REAL;
TYPE
  STDF = (FABS,FSQRT,FSIN,FCOS,FARCTAN,FLN,FEXP);{ADD INT AND ROUND,FRAC}
  STDFLIST = ARRAY[STDF] OF STRING[6];
CONST
  STDFUN: STDFLIST = ('ABS','SQRT','SIN','COS','ARCTAN','LN','EXP');
VAR
  ST:EXPSTR;
  EL,EE,L,P: INTEGER;
  DECPOINT,NEGEXP,FOUND: BOOLEAN;
  F: REAL;
  SF: STDF;

FUNCTION VALU(NUM:REAL):REAL;
VAR
    STNG:STRING;
    CNT:BYTE;
BEGIN
  STR(NUM:10:8,STNG);
  STNG[0]:=#10;
   EL:=0; P:=0; DECPOINT:=FALSE;
    FOR CNT:= 1 TO 10 DO
    BEGIN
     {NUM OF DIGITS CHECK} {IF CH<>'.' THEN P:=P+1}
      IF DECPOINT THEN EL:=EL-1;
      IF (STNG[CNT]='.') AND NOT DECPOINT THEN
      DECPOINT:=TRUE;
     END;{FOR}
            P:=10;
            VALU:=NUM;
 END;


BEGIN
  P:=0; EL:=0;
  IF CH IN ['0'..'9'] THEN
  BEGIN
    F:=0.0; DECPOINT:=FALSE;
    REPEAT
     IF P<10 THEN BEGIN
      F:=F*10.0+(ORD(CH)-48);
      P:=P+1;{NUM OF DIGITS CHECK}
      IF DECPOINT THEN EL:=EL-1;
      NEXTCHAR;
      IF (CH='.') AND NOT DECPOINT THEN
      BEGIN
	DECPOINT:=TRUE; NEXTCHAR;
      END;
     END ELSE
     BEGIN
     ERR:=TRUE;{INFINITY ERROR}
     {OTHER WAY TO CHEK INF ERR CAN BE BY CHEKING POWER FROM REAL VAR BITS}
     CH:=ERRCH;{STOPS FURTHER PROCEEDINGS}
     END;
    UNTIL NOT(CH IN ['0'..'9']);
    IF CH='E' THEN
    BEGIN
      EE:=0; NEXTCHAR;
      IF CH IN ['+','-'] THEN
      BEGIN
	NEGEXP:=CH='-'; NEXTCHAR;
      END ELSE
      NEGEXP:=FALSE;
      WHILE CH IN ['0'..'9'] DO
      BEGIN
        EE:=EE*10+ORD(CH)-48;
        NEXTCHAR;
      END;
      IF NEGEXP THEN EL:=EL-EE ELSE EL:=EL+EE;
    END;
        IF ABS(P+EL)<11 THEN
        F:=F*PWRTEN(EL)
        ELSE
            BEGIN
            ERR:=TRUE;
            CH:=ERRCH;
            END;
    END ELSE{IF CH}
  IF CH='(' THEN
  BEGIN
    NEXTCHAR;
    F:=EXPRESSION;
    IF CH=')' THEN NEXTCHAR ELSE CH:=ERRCH;
  END ELSE
  IF CH='X' THEN
  BEGIN
    NEXTCHAR; F:=VALU(X);
  END ELSE

  BEGIN
    FOUND:=FALSE;
    FOR SF:=FABS TO FEXP DO
    IF NOT FOUND THEN
    BEGIN
      L:=LENGTH(STDFUN[SF]);
      IF COPY(EXPR,POS,L)=STDFUN[SF] THEN
      BEGIN
	POS:=POS+L-1; NEXTCHAR;
	F:=FACTOR(POW);
	CASE SF OF
	  FABS: F:=VALU(ABS(F));{FUNCTION SGN=F/ABS(F) OR OTHER WAY}
	  FSQRT: F:=VALU(SQRT(F));
	  FSIN: F:=VALU(SIN(F));
	  FCOS: F:=VALU(COS(F));
	  FARCTAN: F:=VALU(ARCTAN(F));{TAN INVERSE}
	  FLN:
        IF F<=0 THEN
        BEGIN
        ERR:=TRUE;
        CH:=ERRCH;
        END ELSE
        F:=VALU(LN(F));{ADD LOG FUNC}

	  FEXP:
        IF (F>23) OR (F<-10000) THEN
        BEGIN
        CH:=ERRCH;
        ERR:=TRUE;
        END ELSE
        F:=VALU(EXP(F));{CHECK RANGE, IF InRANGE THEN OK ELSE ERR}
	END;
	FOUND:=TRUE;
      END;
    END;
    IF NOT FOUND THEN CH:=ERRCH;
  END;
  POW:=P+EL;
  FACTOR:=F;
END (*FACTOR*);

BEGIN (*SIGNEDFACTOR*)
  IF CH='-' THEN
  BEGIN
    NEXTCHAR; SIGNEDFACTOR:=-FACTOR(SS);
  END ELSE
  SIGNEDFACTOR:=FACTOR(SS);
END (*SIGNEDFACTOR*);

BEGIN (*TERM*)
  T:=SIGNEDFACTOR(NN);
  WHILE CH='^' DO
  BEGIN
    NEXTCHAR;
    SFC:=SIGNEDFACTOR(NN);
    IF T<=0 THEN
    BEGIN
    ERR:=TRUE;
    CH:=ERRCH;
    END ELSE
    BEGIN
    T:=LN(T)*SFC;

    {FOR FURTHER RAISE IN POWER SIGNEDFACTOR TO BE USED FOR RECURSIVE SOLN.}
    IF (T>23) OR (T<-10000) THEN
    BEGIN
    ERR:=TRUE;
    CH:=ERRCH;
    END ELSE
      T:=EXP(T);
   END;{IF T<1}
  END;{WHILE}
  TERM:=T;
  END (*TERM*);

BEGIN (*SIMEXPR*)
  S:=VALC(TERM,QQ);
  WHILE CH IN ['*','/'] DO
  BEGIN
    OPR:=CH; NEXTCHAR;
    TT:=VALC(TERM,CC);
    CASE OPR OF
      '*': {S:=S*TERM(CC);}
      {QQ & CC ARE NEVER OUT OF THE RANGE -10 TO 10}
          IF ABS(QQ+CC)<11
          THEN
          S:=S*TT
          ELSE BEGIN
          ERR:=TRUE;
          CH:=ERRCH;
          END;
      '/': {USING VARIABLE INSTEAD OF FUNC TERM(CC) WILL REDUCE CALCS}
           IF ((TT<>0) AND (ABS(QQ-CC)<11))
           {1st BIT SGN BIT IN REAL FOR COMMON ABS}
           THEN S:=S/TT
           ELSE BEGIN
           ERR:=TRUE;
           CH:=ERRCH;
           END;
    END;
    QQ:=CC;
  END;
  SIMEXPR:=S;
END (*SIMEXPR*);

BEGIN (*EXPRESSION*)
  E:=VALC(SIMEXPR,PR);{GETTING PREVIOUS POWER HERE FROM SIMEXPR()}
  WHILE CH IN ['+','-'] DO
  BEGIN
    OPR:=CH; NEXTCHAR;
    RR:=VALC(SIMEXPR,NW);
    CASE OPR OF
      '+': IF ((PR<11) AND (NW<11)) THEN E:=E+RR
      ELSE BEGIN
      ERR:=TRUE;
      CH:=ERRCH;
      END;
      {CHK FOR INFINITY ERR OF ADD & SUB}
      '-': IF ((PR<11) AND (NW<11)) THEN E:=E-RR;
      ELSE BEGIN
      ERR:=TRUE; {INFINITY ERROR BY THESE OPERATIONS GO UNDETECTED}
      CH:=ERRCH;
      END;
    END;
    PR:=NW;
  END;
  EXPRESSION:=E;
END (*EXPRESSION*);

BEGIN (*EVALUATE*)
  ERR:=FALSE;
  EXPERR:=ERR;
  POS:=0; NEXTCHAR;
  VALUE:=EXPRESSION;
  IF (CH<>EOFLINE) AND NOT(ERR) {NOW OLD LOGIC WILL WORK}
  THEN EXPERR:=TRUE;
  {ERR-INFINITY ERROR} {EXPERR-EXPRESSION ERROR}
END (*EVALUATE*);

BEGIN (*CALCULATOR*)
             { NO. OF DIGITS INPUT IS 10 CHARS MAX WITH DECIMAL &DIGITS
        (*FUNCTIONS LIKE FRAC,INT,ROUND ECT. SHOULD ALSO BE THERE*)
    (*ALSO DEFINE INFINITY*)
  ERROR CHECKING FOR OUT OF RANGE VALUES IS TO BE PERFORMED}
END (*CALCULATOR*).